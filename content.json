{"pages":[{"title":"404","text":"","path":"404/index.html","date":"08-16","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"08-17","excerpt":""},{"title":"message","text":"","path":"message/index.html","date":"08-17","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"08-16","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"08-16","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"08-17","excerpt":""}],"posts":[{"title":"docker-安装与使用-centos","text":"","path":"2017/03/05/docker-安装与使用-centos/","date":"03-05","excerpt":""},{"title":"ansible 安装和使用(centos)","text":"安装 需要先安装扩展源EPEL sudo yum -y install epel-release 安装ansible 通过Yum安装最新发布版本 通过Yum安装RPMs适用于 EPEL 6, 7, 以及仍在支持中的Fedora发行版. 托管节点的操作系统版本可以是更早的版本(如 EL5), 但必须安装 Python 2.4 或更高版本的Python. Fedora 用户可直接安装Ansible, 但RHEL或CentOS用户,需要 配置 EPEL $ sudo yum install ansible ansible相关配置 修改主机与组配置， 文件位置/etc/ansible/hosts,格式为ini，添加两台主机ip，同时定义两个ip到webservers组，如下。 配置linux主机ssh无密码访问： SSH key的生成和使用 ansible 常用模块 远程命令 command 作为Ansible的默认模块，可以运行远程权限范围所有shell命令； script功能是在远程主机执行主控端存储的shell脚本文件， 相当于scp+shell组合； shell功能是执行远程主机的shell脚本文件。 目标主机修改相应文件的权限 控制端，远程执行目标主机中的shell脚本 shell copy模块 目标主机查看相应文件： stat模块 获取远程文件状态信息，包括atime， ctime, mtime,md5,uid, gid等信息。 get_url模块 实现在远程主机下载指定URL到本地，支持sha256sum文件校验。 远程主机查看： yum模块 Linux平台软件包管理操作，常见的有yum， apt管理方式。 cron模块 远程主机crontab配置 crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。crontab储存的指令被守护进程激活， crond常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为cron jobs。 远程主机查看： mount模块 远程主机分区挂载 service模块 远程主机系统服务管理。 先远程安装一个nginx,用于测试 ： 远程主机检查，是否安装成功： sysctl包管理模块 远程linux主机sysctl配置。 此处，有待验证 uer服务模块。 远程用户管理添加用户：删除用户：","path":"2017/03/02/ansible-安装和使用-centos/","date":"03-02","excerpt":""},{"title":"快速搭建属于自己的Ubuntu开发环境（Python）","text":"说明： 系统Ubuntu 16.04LTS，主要配置Python开发环境 简单的必备工具安装： 安装git sudo apt install git 命令清单github配置shh ssh-keygen -t rsa -C &quot;你的邮箱&quot; # 生成，三次默认为空即可 cat id_rsa.pub #查看 ssh git@github.com #测试 安装pip sudo apt install python-pip pip换源修改配置文件（若没有，新建即可） sudo mkdir ~/.pip sudo vim ~/.pip/pip.conf [global] index-url = https://pypi.douban.com/simple 安装zsh sudo apt-get install zsh 配置： sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 官网 安装virtulenvwrapper pip install virtualenv pip install virtualenvwrapper 配置环境变量 mkdir -p $WORKON_HOME 配置到zsh： sudo vim .zshrc export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.sh 常用命令： ● workon env1: 切换虚拟环境 ● mkvirtualenv: 新建工作环境 ● rmvirtualenv: 删除工作环境 ● lsvirtualenv: 列出虚拟环境 ● cdproject: 切换到工程目录 常用软件安装配置 安装搜狗输入法（官网下载安装包） sudo dpkg -i sogoupinyin_2.1.0.0082_amd64.deb 不需重启，自行配置，调出输入法（添加，注意可能要去掉一个小勾） 安装teamviewer下载地址 安装shadowsocks 服务器： sudo apt-get update sudo apt-get install -y python-pip pip install shadowsocks ssserver -c config.json -d start 参考配置 客户端下载 安装指南 vultr服务器 开发工具安装配置 安装pycharm（需要先安装jdk）下载地址 安装JDK（特别耗时） sudo add-apt-repository ppa:webupd8team/java sudo apt-get update sudo apt-get install oracle-java8-installer 安装pycharm 到官网下载安装包 到下载目录下进行解压 cd Downloads/ sudo tar xfz pycharm-*.tar.gz 运行解压后的文件夹中的bin目录下的pycharm.sh文件 cd pycharm-community-3.4.1/bin/ ./pycharm.sh #或者sh pycharm.sh 安装过程中询问是否导入settings，选择不导入-&gt;OK.然后全部是默认，根据提示选择 参考地址 安装docker官网 方法(简单方法) sudo wget -qO- https://get.docker.com/ | sh参考地址 安装步骤（详细）参考1参考2 Docker 常用命令： docker images：列出所有镜像(images) docker ps：列出正在运行的(容器)containers docker pull ubuntu：下载镜像 docker run -i -t ubuntu /bin/bash：运行ubuntu镜像 docker commit 3a09b2588478 ubuntu:mynewimage：提交你的变更，并且把容器保存成Tag为mynewimage的新的ubuntu镜像.(注意，这里提交只是提交到本地仓库，类似Git) docker 安装mysql 查找 docker search mysql 拉取（特别耗时） docker pull mysql:5.6 运行容器，使用mysql镜像 docker run -p 3306:3306 --name mymysql -v $PWD/conf/my.cnf:/etc/mysql/my.cnf -v $PWD/logs:/logs -v $PWD/data:/mysql_data -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6 命令说明： ● -p 3306:3306：将容器的3306端口映射到主机的3306端口 ● -v $PWD/conf/my.cnf:/etc/mysql/my.cnf：将主机当前目录下的conf/my.cnf挂载到容器的/etc/mysql/my.cnf ● -v $PWD/logs:/logs：将主机当前目录下的logs目录挂载到容器的/logs ● -v $PWD/data:/mysql_data：将主机当前目录下的data目录挂载到容器的/mysql_data ● -e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码 查看容器启动情况 docker ps 参考1 (必看) 参考2 （可选） 安装navicat官网下载 如果Ubuntu语言环境为英文，navicat可能会出现乱码问题 解决中文乱码问题，注意下面文章内容，最后输出的内容要一致，你看需要修改三次（export 3次） export LANG=zh_CN.UTF-8 export LANGUAGE=zh_CN export LC_CTYPE=zh_CN.UTF-8 参考1 其他软件的安装和配置 安装hexo 先安装nodejs官网下载 下载完后解压，添加到系统命令 sudo ln -s /home/saiun/Downloads/node-v6.9.4-linux-x64/bin/node /usr/local/bin/node sudo ln -s /home/saiun/Downloads/node-v6.9.4-linux-x64/bin/npm /usr/local/bin/npm 参考 执行如下命令安装Hexo： sudo npm install -g hexo 添加到系统命令 sudo ln -s /home/saiun/Downloads/node-v6.9.4-linux-x64/bin/hexo /usr/local/bin/hexo 参考1 调整Ubuntu界面(16.04STL)： 打开终端，然后输入下面这个命令，即可将启动器移到屏幕底部： gsettings set com.canonical.Unity.Launcher launcher-position Bottom 如果你使用后，觉得不喜欢，还可以恢复到屏幕左边，只要运行： gsettings set com.canonical.Unity.Launcher launcher-position Left","path":"2017/01/12/快速搭建属于自己的Ubuntu开发环境（Python）/","date":"01-12","excerpt":""},{"title":"UNIX环境下的编程第八章","text":"进程控制进程标识每个进程都有一个非负整型表示的唯一进程ID。因为进程ID标示符，总是唯一的，常将其用来作其他标识符的一部分以保证其唯一性。 ID为0的进程通常是调度进程，常常被称为交换进程。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。进程ID为1通常是init进程，在自举过程结束时由内核调用。某些UNIX的虚拟存储器实现中，进程ID2是页守护进程，此进程负责支持虚拟存储系统的分页操作。 函数fork一个现有进程可以调用fork函数创建一个新进程。一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。 strlen计算不包括终止null字节的字符串长度，而sizeof需要进行一次函数调用，而对于sizeof而言，因为缓冲区已用已知字符串进行初始化，其长度是固定的，所以sizeof是在编译时计算缓冲区长度。 文件共享在重定向父进程的标准输入时，子进程的标准输出也被重定向。实际上，fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中 vfork函数的调用序列和返回值与fork相同，但两者的语义不同。vfork保证子进程先运行，在它调用exec或者exit之后父进程才可能被调度运行，当子进程调用这两个函数中的任意一个时，父进程会恢复运行。 exit函数一个由init进程收养的进程终止时，它不会变成一个僵死进程。因为init被编写成无论何时只要有一个子进程终止，ini就会调用一个wait函数取得最终状态。这样也就防止了在系统中塞满僵死进程。 调用wait和waitpid的进程可能会发生：如果其所有子进程都还在运行，则阻塞。如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。如果它没有任何子进程，则立即出错返回。 waitpid函数提供了wait函数没有的三个功能（1）waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态。（2）waitpid踢欧冠呢了一个wait的非阻塞版本。有时希望获取一个子进程的状态，但不想阻塞。 (3)waitpid通过WUNTRACED和WCONTINUED选项支持作业控制。 函数waitid,此函数类似与waitpid，但提供了更多的灵活性。 与waitpid相似，waitid允许一个进程指定要等待的子进程。 函数wait3和wait4他们提供的功能比POSIX.1函数wait，waitpid和waitid所提供功能的要多一个，这个与附加参数有关。 竞争条件 如果希望一个进程等待一个子进程终止，则它必须调用wait函数中的一个。如果一个进程要等待其父进程终止，则可以使用下列形式循环： 12while(getppid()!=1) sleep(1); 这种形式的循环称为论循，它的问题是浪费了ＣＰＵ时间，因为调用者每隔１S都被唤醒，然后进行条件测试。 函数exec，当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。 用setuid函数设置实际用户ID和有效用户ID。与此类似，可以用setgid函数设置实际ID和有效ID。 现在所有UNIX系统都支持解释器文件。这种文件是文本文件夹，其起始行的形式是： #！pathname[optional-argument] 在感叹号和pathname之间的空格是可选的。 system函数，在实现中调用了fork，exec和waitpid。","path":"2017/01/04/UNIX环境下的编程第八章/","date":"01-04","excerpt":""},{"title":"UNIX环境下的编程第七章","text":"进程环境C语言总是从main函数开始执行。main函数的原型是：int main（int argc ， char ×argv[1])其中 ，argc 是命令行参数的数目，argv是指向参数的各个指针所构成的数组。 进程终止五中正常的终止：（1）从main返回（2）调用exit（3）调用_exit 或 _Exit; (4) 最后一个线程从其启动历程返回 (5) 从最后一个线程调用pthread_exit 异常终止：（6）滴啊用abort（7）接到一个信号（8）最后一个线程对取消请求做出响应 exit 函数总是执行一个标准I/O库的清理关闭操作。对于所有打开流调用fclose函数。这造成输出缓冲中的所有数据都被冲洗（写到文件上）。 函数atexit 按照ISOC的规定，一个进程可以登记多个至32个函数，，这些函数将由exit自动调用。我们称这些函数为终止处理程序，并调用atexit函数来登记这些函数。 其中，atexit的参数是一个函数的地址，当调用此函数的时候，无需向它传递任何参数，也不期望它返回一个值，exit调用这些函数的顺序与它们登记的顺序相反。同一个函数如若登记多次，也会被调用多次。 命令行参数 当执行一个程序是，调用exec的进程可将命令行参数传递给该程序。 环境表 每个程序都接受到一张环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包括一个以null结束的C字符串地址。全局变了environ则包含了该指针的地址。 C程序的存储空间布局 正文段。这是由CPU执行的机器指令部分。通常，正文段是可以共享，所以即使是频繁执行的程序在存储器中也只需要有一个副本，另外，正文段常常是只读的，以防止程序由于意外而修改其指令。 初始化数据段。通常将此段称为数据段，它包含了程序中需要明确地赋初值的变量 未初始化数据段。通常将此段称为bss段，这一名称来源于早期汇编程序的一个操作符，意思是“由符号开始的块”，在程序开始执行之前，内核将此段中数据初始化为0或空指针。 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。 堆。通常在堆中进行动态存储分配。由于历史上形成的惯例，堆位于初始化数据段和栈之间。 共享库 共享库使得可执行文件中不再需要包含公用的库函数，而只需要在所有进程都可引用的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个函数库时，用动态链接方法将程序与共享库函数相连接。 存储空间分配 ISOC说明了3个用于存储空间动态分配的函数。 （1）malloc,分配指定字节数的存储区。此存储区中的初始值不确定。 （2）calloc，为指定数量指定长度的对象分配存储空间。该空间中的每一位（bit）都初始化为0 （3）realloc,增加或减少以前分配区的长度。当增加长度时，可能需将以前分配的内容移到另一个足够大的区域，以便在尾端提供增加的存储区，二新曾区域的初始值则不确定。 如若一个进程调用mallco函数，但却忘记调用free函数，那么该进程占用的存储空间就会连续增加，这被称为泄漏。 替代的存储空间分配程序 libmalloc，vmalloc，quick-fit，jemalloc，TCMalloc，alloca 环境变量 3个函数的操作 putenv 取形式为name=value的字符串，将其放到环境表中。如果name已经存在，则先删除其原来的定义。 setenv将name设置为value.如果在环境中name已经存在，那么 （a）若rewrite非0，则首先删除其现有的定义； （b）若rewrite为0，则不删除其现有定义（name不设置新的value，而且也不出错）。 unsetenv 删除name的定义。即使不存在这种定义也不算出错。 函数setjmp和longjmp 在C中，goto语句是不能跨越函数的，而执行这种类型跳转功能的是函数setjmp和longjmp.这两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的。","path":"2017/01/03/UNIX环境下的编程第七章/","date":"01-03","excerpt":""},{"title":"UNIX环境下的编程第六章","text":"系统数据文件和信息由于历史原因，口令文件是/etc/passwd，而且是一个ACSSII文件。通常有一个用户名为root的登录项，其用户ID是0 getpwuid函数由login（1）程序使用，它将i节点中的数字用户id映射为用户登录名。 调用getpwent时，它返回口令文件中的下一个记录项。 函数setpwent反绕它所使用的文件，endpwent则关闭这些文件。在使用getpwent查看完口令文件之后，一定要调用endpwent关闭这些文件。 阴影口令现在，某些系统将加密口令存放在另一个通常称为阴影口令的文件中。该文件至少要包含用户名和加密口令。 阴影口令部署一般用户可以读取的。仅有少数几个程序需要访问加密口令，如login（1）和passwd（1），这些程序常常是设置用户ID为root的程序。有了阴影口令之后，普通口令文件/etc/passwd可有各用户自由读取。 组文件gr_mem是一个指针数组，其中每个指针指向一个属于该数组的用户名。该数组以null指针结尾。 附属组ID使用附属组ID的优点是不必再显式地经常更改组。一个用户会参与多个项目。因此也就要同时属于多个组。 其他数据文件一般情况下，对于每个数据至少三个函数。（1）get函数：读取下一条记录，如果有需要，还会打开该文件。（2）set函数：打开想要数据文件（如果未打开），然后反绕文件。（3）end函数：关闭相应数据文件。 登录账户记录utmp文件记录当天登录到系统的各个用户；wtmp文件跟踪各个登录和注销事件。 系统标识uname函数，它返回与主机和操作系统有关的信息。BSD派生的系统提供gethostname函数，它只返回主机名。 时间和日期历程。 clock_gettime函数可用于获取指定时钟的时。","path":"2017/01/01/UNIX环境下的编程第六章/","date":"01-01","excerpt":""},{"title":" UNIX环境下的编程第五章","text":"标志I/O所有I/O函数都是围绕文件描述符的。当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的I/O操作，对于标准I/O库，它们的操作是围绕流进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流和一个文件相关联。 流的定向决定了所读，写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。根据你使用的是单字节还是多字节的I/O函数来确定该流是字节定向，还是宽定向的。 只有两个函数可以改变流的定向。freopen函数清除一个流的定向， fwide函数可以用于设置流的定向。 标志输入，标志输出和标准错误。这三个流可以自动地被进程引用。 标志I/O提三种类型的缓冲全缓冲行缓冲不带缓冲 默认惯例标准错误是不带缓冲的。若是指向终端设备的流，则是行缓冲的；否者是全缓冲的。 fopen 函数打开路径名为 pathname的指定文件freopen函数在一个指定的流上打开一个指定的文件。如果该流已经打开，则先关闭该l流，如果该流已经定向，则先清除该定向。fdopen函数去一个已有的文件描述符，并使用一个标准的I/O流与太函数符相结合。 打开流后，则有三种不同类型的非格式化I/O中进行选择，对其进行读、写操作。（１）每次一个字符的I/O（２）每次一行的I/O（３）直接I/O 定位流 有三种方法定位标准I/O流（１）ftell和 fseek函数。他们都假定文件的位置可以存放在一个长整型中。（２）ftello 和fseekohns函数，使用off_t数据类型代替了长整型。 （３）fgetpos和 fsetpos他们使用抽象数据类型fpos_t记录文件的位置。 格式化的输出是由五个printf函数来处理的。格式化的输入是由三个scanf函数来处理的。 每个标准流都有一个与其相关的描述符，可以对一个流调用fileno函数获得其描述符。 临时文件tmpnam函数产生一个与现有文件名不同的一个有效路径名字字符串。tmpfile函数经常使用的标准UNIX技术是先调用tmpnam 产生一个唯一的路径名。然后用该路径名创建一个文件，并立即 unlink它。 内存流三个可以用于创建内存流的函数fmemopen函数允许调用者提供缓冲去用于内存流。open_memstream函数创建的流是面向字节的，open_wmemstream函数创建的流是面向宽字节的。","path":"2017/01/01/UNIX环境下的编程第五章/","date":"01-01","excerpt":""},{"title":"UNIX环境下的编程第四章","text":"文件和目录函数stat，fstat ，fstatat 和lstat 一旦给出pathname,stat 函数将返回与此命名文件有关的信息结构。fstat函数获得已描述符fd上打开文件的有关信息。lstat函数类似与stat，但是当命名的文件是一个符号链接时而不是由该符号链接引用的文件的信息。当以降序遍历目录层次结构是，需要用到lstat。 stat函数使用最多的地方就是ls -l命令，用其可以获得有关一个文件的所有信息。 文件类型（１）普通文件这是最常用的文件类型，这种文件包含了某种形式的数据。（２）目录文件这种文件包含了其他的名字一级指向与这些文件有关信息的指针。（３）块特殊文件。这种类型的文件提供（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。（４）字符特殊文件。这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中所有设备要么是字符特殊文件，要么是块特殊文件。（５）ＦＩＦＯ。这种类型的文件用于进程通信，有时也称为命名管道。（６）嵌套字。这种类型的文件用于进程间的网络通信。嵌套字也可以用于在一台宿机上进程之间的非网络通信。（７）符号链接。这种类型的文件指向另外一个文件。 设置用户ＩＤ和设置组ＩＤ 实际用户ID和实际用户ID标识我们究竟是谁有效用户ID，有效组ID以及附属组ID决定了我们的文件访问权限。 保存的设置用户ＩＤ和保存的设置组ＩＤ在执行一个程序时包含了有效用户ＩＤ和有效组ＩＤ的副本。 文件访问权限 st_mode 值也包含了对文件的访问权限。ｕ表示用户，ｇ表示组，o表示其他，而不是所有者。 进程每次打开，创建，或者删除一个文件时，内核就对文件进行访问测试，这种测试可能设计文件的所有者，进程有效ＩＤ以及进程的附属ＩＤ。 新文件和目录的所有权（１）新文件的组ID可以是进程的有效组ＩＤ（２）新文件的组ＩＤ可以是它所在目录的组ID 函数access和faccessate函数是按实际用户ＩＤ和实际组ＩＤ进行访问权限测试的。 函数ｕｍａｓｋ为进程设置文件模式创建屏蔽字，并返回之前的值。在进程创建一个新文件或目录时，就一定会使用文件模式创建屏蔽字。 函数ｃｈｍｏｄ，ｆｃｈｍｏｄ和ｆｃｈｍｏｄａｔ这３个函数是我们可以更改现有文件的访问权限。 粘着位，如果对一个目录设置了粘着位，只有对该目录具有写权限的用户并且满足以下条件之一，才能删除或者重命名该目录下的文件：×拥有此文件；×拥有此目录；×是超级用户； 函数chｏｗｎ，ｆｃｈｏｗｎ，ｆｃｈｏｗｎａｔ和ｌｃｈｏｗｎ。除了所引用的文件是符号链接以外，这四个函数的操作类似。 文件长度，ｓｔａｔ结构成员ｓｔ_size表示以字节为单位的长度。此字段只对普通文件，目录文件和符号链接有意义。 文件中的空洞，空洞是由所设置的偏移量超过文件尾端，并写入了某些数据后造成的。 文件武断，有时候我们需要在文件尾端截去一些数据以缩短文件。为了武断文件可以调用函数ｔｒｕｎｃａｔｅ和ｆｔｒｕｎｃａｔｅ。 文件系统，我们可以把磁盘分成一个或多个分区。每个分区可以包含一个文件系统。ｉ节点是固定长度的记录项，它包含有关文件的大部分信息。 函数ｌｉｎｋ，ｌｉｎｋａｔ，ｕｎｌｉｎｋ，ｕｎｌｉｎｋａｔ和ｒｅｍｏｖｅ任何一个文件可以有多个目录指向其ｉ节点。创建一个指向现有文件的链接的方法是使用ｌｉｎｋ函数或ｌｉｎｋａｔ函数。 函数rｅｎａｍｅ和ｒｅｎａｍｅａｔ文件或目录可以用这两个函数进行重命名。 符号链接是对一个文件的间接指针，硬链接直接指向文件的ｉ节点。 可以用ｓｙｍｌｉｎｋ或ｓｙｍｌｉｎｋａｔ函数创建一个符号链接。 文件时间，修改时间st_mtim 和状态时间 st_ctim之间的区别。修改时间是指文件内容最后一次被修改的时间，状态更改时间是该文件的ｉ节点最后一次被修改的时间。 函数ｆｕｔｉｍｅｎｓ，ｕｔｉｍｅｎｓａｔ和ｕｔｉｍｅｓ对文件的访问和修改时间可用这几个函数。 函数ｍｋｄｉｒ，ｍｋｄｉｒａｔ和ｒｍｄｉｒ创建目录和删除目录。 对于某个目录具有访问权限的任一用户都可以度该目录。只有内核才能写目录。一个目录的写权限位和执行权限位决定了在该目录下能否建立新文件以及删除文件，它们并不表示能否写目录本书。 函数ｃｈｄｉｒ，ｆｃｈｄｉｒ和ｇｅｔｃｗｄ调用chdir或ｆｃｈｄｉｒ函数可以更改当前工作目录。","path":"2016/12/30/UNIX环境下的编程第四章/","date":"12-30","excerpt":""},{"title":"UNIX环境下的编程第三章","text":"函数 open和openat 调用这两个函数均可以打开或创建一个文件。 O_RDONLY只读打开O_WRONLY只写打开O_RDWR 读写，打开 大多数实现将以上三者分别定义为０，１，２，与早期的程序兼容。 O_DSYNC和O_SYNC标志有微妙的区别。仅当文件属性需要更新以反映文件数据变化s时。O_DSYNC标志才影响文件属性。而设置O_SYNC标志后，数据和属性总是同步更新。当文件用O_DSYN标志打开，在重写其现有的部分内容时，文件时间属性不会同步更新。与此相反，如果文件是用O_SYNC标志打开，那么对文件的每一次write 都将在write返回前更新时间，这与是否改现写有字节或追加写文件无关。 函数creat创建一个新文件，在open函数更新之后，也就不需要单独creat函数了 函数close关闭一个打开文件，关闭一个文件时还会释放进程加在文件上所有记录锁。 函数lseek显式地为一个打开文件设置偏移量。 函数read 从打开文件中读数据。如果read成功，则返回读到的字节数。如已达到文件的尾端。则发回０。 函数ｗrite向打开文件写数据。 原子操作指的是由多步组成一个操作。调用pread相当于先调用lseek后调用read，但是有区别，调用pread时，无法中断其定位和读操作。不更新当前文件位移。调用pwrite相当于调用lseek后调用write，但也与它们有类似的区别。 函数dup和dup2 都可用来复制一个现有的文件描述符。dup返回的新文件描述符一定是当前可用文件的miaosfd2参数指定新描述符的值。 函数sync,sync和fdatasyncsync只是将所有修改过的模块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。通常，守护进程周期性地调用（一般每隔30秒）sync函数。这就保证了定期冲洗（flush）内核的块缓冲区。命令sync(1)也调用sync函数。fsync函数只对有文件描述符fd指定的文件起作用，并且等待写磁盘操作结束才返回。fsync可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。fdatasync函数类似与fsync，但它只影响文件的数据部分。而除数据外，fsynv还会同步更新文件的属性。 函数fcntl可以改变已经打开文件的属性。（１）复制一个已有的描述符（２）获取／设置文件描述符标志（３）获取／设置文件状态标志（４）获取／设置异步I/O所有权（５）获取／设置记录锁 函数ioctl一直是I/O操作的杂物箱。不能用本章其他函数表示的I/O操作通常都能用iocl表示。 ／dev/fd目录，较新的系统都提供这个目录，其目录项是名为０，１，２等的文件。打开／dev/fd/nd等效与复制描述n。","path":"2016/12/29/UNIX环境下的编程第三章/","date":"12-29","excerpt":""},{"title":"UNIX环境下的编程第二章","text":"unix系统: FreeBSD Linux Mac OS X Solaris 等 函数sysconf ，pathconf 和 fpathconf linux 中另一个潜在的不精确的来源是 pathconf 和fpathconf 函数都是在C库函数中实现的，这些函数返回值的配置限制依赖于底层的文件系统类型，因此如果你的文件系统不被C库熟知的话，函数返回的是一个猜测值。 pathconf 的返回值是基于工作目录的相对路径名中的最大长度，而工作目录是其第一个参数。所以，指定根目录为第一个参数，并将得到的返回值加一作为结果值。如果pathconf指明PATH_MAX是不确定的，那么我们只能猜测某个值。 基本数据类型头文件&lt;sys/types.h&gt;中定义了某些与实现相关的数据类型，它们被称为基本数据类型。还有很多这种数据类型定义在其他头文件中。这头文件中，这些数据类型都是用Ｃ的typedef来定义的。他们绝大多数都以_t结尾。用这种方式定义这些数据类型之后，就不需要考虑因系统不同而变化的程序实现细节。 标准之间的冲突POSIX.1服从ISO C标准。然而它们之间还是存在着一些差别。sysconf 函数用来获取每秒滴答数，用于表示times函数的返回值。ISO C和POSIX.1用同一种数据类型(clock_t)来保存对时间的测量，但定义了不同的单位。这种差别在Solais中看到，其中clock返回微秒数，而sysconf为每秒滴答数返回的值是100。因此，我们在使用clock_t类型变量时，必须十分小心以免混淆不同的时间单位。","path":"2016/12/28/UNIX环境下的编程第二章/","date":"12-28","excerpt":""},{"title":"UNIX环境下的编程第一章","text":"知识点归纳1. 我们最熟悉的标准I/O函数是printf。在调用printf 的程序中，总是要包含 &lt;stdio.h&gt;（但是本书中，该头文件包含在apue.h中）,该头文件包含了所有标准I/O函数的原型。 2. UNIX系统每个进程都有一个唯一的数字标识符，称为进程ID(process ID)。进程ID总是一个非负整数。 3. fork 创建一个新进程。调用一次，返回两次，对子进程返回0，对父进程返回新的子进程的进程ID。 4. errno 的两条规则。第一条：如果没有出错，其值不会被例程清除。因此仅当函数的返回值指明出错时。才会验其值。第二条：任何函数都不会将errno 值设置为０，而且在 &lt;errno.h&gt; 中定义的所有常量都不为０。 5. 程序打印用户ID和组ID UNXI 体系结构 内核的接口被称为内核，因为它相对比较小，而且位于环境的核心。内核接口被称为系统调用，公用函数库构建在系统调用接口之上，应用程序既可以使用系统调用也可以使用公用函数库。shell 是一个特殊的应用程序，为运行其他应用程序提供了一个接口。 文件和目录UNXI 文件系统是目录和文件的一种层次结构，所有的起点是称为根的目录，这个目录的名称是一个字符“／”。 文件名：目录中的各个名字称为文件名。只有斜线（／）和空格不能出现在文件名。 创建新目录的适合，会自动创建两个文件名：.(称为点) 和..(称为点点)，点指向当前目录，点点指向父目录，在最高层次目录中，点与点点相同。 路径名：由斜线分割的一个或多个文件名组成的序列（也可以一斜线名开头）构成路径名，以斜线名开头的路径称为绝对路径，否则称为相对路径。","path":"2016/12/28/UNIX环境下的编程第一章/","date":"12-28","excerpt":""}]}